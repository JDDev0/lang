lang.name = Function Pointer
lang.version = v1.0.0

# Function Pointer
# Create function
# fp.name = ($var) -> { # Function head: Parameter definition
#     [CODE...] # Function body: Code execution
# } # Function end
# Call function:
# fp.name($var)

# Create:
{ # Normal
	# Without vars:
	# fp.name = () -> {
	fp.test = () -> {
		func.printTerminal(2, This is a Test!)
		func.printTerminal(1, Ok...)
	}
	fp.test()
	
	# With vars:
	#             Var    Array  Function pointer
	# fp.name = ($var1,  &var2,     fp.var3) -> {
	fp.printRandom = ($min, $max) -> {
		$rand = func.addi(func.modi(func.rand(), func.addi(func.subi($max, $min), 1)), $min)
		func.printTerminal(4, Random number: $rand!)
	}
	fp.printRandom(42, 42)
	fp.printRandom(41, 42)
	fp.printRandom(0, 42)
}
{ # One-Line
	# fp.name = () -> [CODE...]
	fp.printNormal = ($text) -> func.printTerminal(-1, $text)
	fp.printNormal(100 - TESTed!)
}

# Return:
fp.testRet = () -> {
	func.printTerminal(1, I was executed!)
	return # Will return -> Everything after won't be executed
	func.printTerminal(1, Hello?)
}
fp.testRet()

fp.getRandom = () -> return func.rand() # Will return a value to the function caller
$ran = fp.getRandom()
func.printTerminal(-1, $ran)
func.printTerminal(-1, fp.getRandom())

# Function Pointer as return value
fp.func = () -> return YES!
fp.get = () -> {
	return fp.func
}
$g = fp.get()
func.printTerminal(4, $g)
$g = fp.get()()
func.printTerminal(4, $g)

# Copy function pointer
# Function Pointer
# fp.name = fp.name
fp.orig = () -> {
	func.printTerminal(5, A function)
}
fp.orig() # Prints: "A function"
fp.copy = fp.orig # Copying
fp.copy() # Prints: "A function"
# Changing original function
fp.orig = () -> func.printTerminal(2, An other function)
fp.orig() # Prints: "A other function"
fp.copy() # Still prints "A function"

# Predifined function
# fp.name = func.name
fp.pt = func.printTerminal
fp.pt(-1, Function Pointer!)
func.printTerminal(-1, Function Pointer!)

# Function Poitner argument duplication
# If not enough arguments are provided, the compiler will copy the
#   last argument given. If no argument was given, all variables will be empty
# If too many arguments are given, the compiler will ignore them
fp.manyArgs = ($a, $b, $c, $d, $e, $f, $g) -> {
	func.printTerminal(1, |$a  $b  $c  $d  $e  $f  $g|)
}
fp.manyArgs()
fp.manyArgs(A)
fp.manyArgs(A, B)
fp.manyArgs(A, B, C)
fp.manyArgs(A, B, C, D)
fp.manyArgs(A, B, C, D, E)
fp.manyArgs(A, B, C, D, E, F)
fp.manyArgs(A, B, C, D, E, F, G)
fp.manyArgs(A, B, C, D, E, F, G, H)
fp.manyArgs(A, B, C, D, E, F, G, H, I)

# Varargs
{
	# The last parameter can be a vargargs parameter ($<name>... [Text varargs] or &<name>... [Array varargs])
	
	# Text varargs
	# Everything after the argument prior to the last argument will be combined as text and written to $args
	fp.testTextVarArgs = ($num, $args...) -> {
		func.printTerminal(5, \nFrom "fp.testTextVarArgs")
		func.printTerminal(3, \$num: $num)
		func.printTerminal(3, \$args: $args)
		func.printError()
	}
	fp.testTextVarArgs()
	fp.testTextVarArgs(1)
	fp.testTextVarArgs(1, 2)
	fp.testTextVarArgs(1, 2, 3)
	fp.testTextVarArgs(1, 2, 3, 4)
	fp.testTextVarArgs(1, 2, 3, 4, 5)
	fp.testTextVarArgs(1, 2, 3, 4, 5, 6)
	
	# Array varargs
	# Everything after the argument prior to the last argument will be combined as Array and written to &args
	fp.testArrayVarArgs = ($num, &args...) -> {
		func.printTerminal(5, \nFrom "fp.testArrayVarArgs")
		func.printTerminal(3, \$num: $num)
		func.printTerminal(3, \&args: func.arrayGetAll(&args))
		func.printError()
		func.printTerminal(3, length(\&args): func.arrayLength(&args))
		func.printError()
	}
	fp.testArrayVarArgs()
	fp.testArrayVarArgs(1)
	fp.testArrayVarArgs(1, 2)
	fp.testArrayVarArgs(1, 2, 3)
	fp.testArrayVarArgs(1, 2, 3, 4)
	fp.testArrayVarArgs(1, 2, 3, 4, 5)
	fp.testArrayVarArgs(1, 2, 3, 4, 5, 6)
}

# Every value at function call will be copied to function pointer:
# Changed values
{
	$a = 42
	fp.mod = ($a) -> {
		$a = 43
		func.printTerminal(-1, Local: $a)
	}
	fp.mod($a)
	fp.mod = () -> {
		$a = 44
		func.printTerminal(-1, Inner: $a)
	}
	fp.mod()
	func.printTerminal(-1, Outer: $a)
	
	# If you want to copy a local variable to the caller: See [07_loops.lang: func.copyAfterFP]
}

# Use values that are defined after function pointer definition
{
	fp.printNot = () -> {
		func.printTerminal(2, $not)
	}
	
	fp.printNot() # Will print "$not"
	$not = I'm defined!
	fp.printNot() # Will print "I'm defined!"
}

# Returning of assignment
{	
	$tmp = 0
	$val = 42
	fp.genNextNumber = () -> {
	    func.copyAfterFP($[tmp], $[tmp]) # See [07_loops.lang: func.copyAfterFP]
		return $tmp = func.addi($val, $tmp) # Not supported: Empty assignment / translation and translations
	}
	func.printTerminal(4, fp.genNextNumber())
	func.printTerminal(4, fp.genNextNumber())
	func.printTerminal(4, fp.genNextNumber())
	
	&a = func.arrayMake(10)
	func.arraySetAll(&a, 6, 8, 9, 4, 2, 0, 1, 5, 3, 7)
	$tmpIndex = 0
	fp.next = (&arr) -> {
		func.copyAfterFP($[tmpIndex], $[tmpIndex]) # See [07_loops.lang: func.copyAfterFP]
		return $tmpIndex = func.arrayGet(&arr, $tmpIndex)
	}
	func.printTerminal(3, fp.next(&a))
	func.printTerminal(3, fp.next(&a))
	func.printTerminal(3, fp.next(&a))
}

# Set Function Pointer to a returned value
{
	fp.a = func.printError
	fp.a(0-ABC)
	fp.b = () -> return fp.a
	fp.b()(1-ABC)
	fp.c = fp.a
	fp.c(2-ABC)
	fp.d = fp.b()
	fp.d(3-ABC)
	fp.e = func.randChoice(fp.a, fp.c)
	fp.e(4-ABC)
	fp.f = func.randChoice(func.println, func.errorln)
	fp.f(5-ABC)
	fp.g = func.exec(return func\!.printError)
	fp.g(6-ABC)
	fp.h = func.exec(return (\$text...) -> {\nfunc\!.printError(\$text)\n})
	fp.h(7-ABC)
	fp.i = func.exec({{{
		return ($text...) -> {
			func.printError($text)
		}
	}}})
	fp.i(8-ABC)
}

# Anonymous Function Pointer as return value
{
	fp.a = () -> {
		return ($text...) -> {
			func.printTerminal(2, $text)
		}
	}
	fp.a()(abc, def)
	fp.b = fp.a()
	fp.b(def, abc)
}

# An other possibility for "returning" a value
{
	# With call by value
	{
		$a = 42
		fp.changeValue = ($ptr) -> {
			$*ptr = changed value # Pointer dereferencing
		}
		func.printTerminal(6, $a)
		fp.changeValue($[a]) # Provid pointer to "$a"
		func.printTerminal(6, $a)
	}
	
	# With call by pointer
	{
		$a = 42
		fp.changeValue = ($[ptr]) -> {
			$*ptr = changed value # Pointer dereferencing
		}
		func.printTerminal(5, $a)
		fp.changeValue($a) # A pointer will be created for "$a" during the call process
		func.printTerminal(5, $a)
	}
}

# End the program early & return DataObject
func.printTerminal(-1, Will be executed)
return 42.42 # A return statement outside of a function pointer function body will end the program execution early
func.printTerminal(-1, Won't be executed)
