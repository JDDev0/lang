lang.name = Operators
lang.version = v1.0.0

# Operators
# General
# (opr)               - Grouping
# @opr                - Length
# ^opr                - Deep copy
# opr1 <=> opr2       - Spaceship
# opr1 ~~ opr2        - Instance of
# opr1 ?: oprr2       - Elvis
# opr1 ?? opr2        - Null coalescing
# opr1 ? opr2 : opr3  - Inline if

# Math
# (opr)               - Grouping
# opr1 ** opr2        - Power
# +opr                - Positive
# -opr                - Inverse
# ~opr                - Bitwise not
# ▲opr                - Increment (Will NOT change value of opr)
# ▼opr                - Decrement (Will NOT change value of opr)
# opr1 * opr2         - Multiplication
# opr1 / opr2         - Division
# opr1 ~/ opr2        - Truncation division
# opr1 // opr2        - Floor division
# opr1 ^/ opr2        - Ceil division
# opr1 % opr2         - Modulo
# opr1 + opr2         - Addition
# opr1 - opr2         - Subtract
# opr1 << opr2        - Left shift
# opr1 >> opr2        - Right shift
# opr1 >>> opr2       - Right zero shift
# opr1 & opr2         - Bitwise and
# opr1 ^ opr2         - Bitwise xor
# opr1 | opr2         - Bitwise or

# Condition
# (opr)               - Grouping
# !opr                - Not
# opr1 == opr2        - Equals
# opr1 != opr2        - Not equals
# opr1 =~ opr2        - Matches
# opr1 !=~ opr2       - Not matches
# opr1 === opr2       - Strict equals
# opr1 !== opr2       - Strict not equals
# opr1 < opr2         - Less than
# opr1 > opr2         - Greater than
# opr1 <= opr2        - Less than or equals
# opr1 >= opr2        - Greater than or equals
# opr1 && opr2        - And
# opr1 || opr2        - Or

# Assignments
# expr1 = expr2       - Normal assignment
# expr1 ?= expr2      - Set condition assignment       (Is equivalent to "expr1 = parser.con(expr2)")
# expr1 := expr2      - Set math assignment            (Is equivalent to "expr1 = parser.math(expr2)")
# expr1 $= expr2      - Set operation assignment       (Is equivalent to "expr1 = parser.op(expr2)")
# expr1 += expr2      - Addition assignment            (Is equivalent to "expr1 = parser.op((expr1) + (expr2))")
# expr1 -= expr2      - Subtract assignment            (Is equivalent to "expr1 = parser.op((expr1) - (expr2))")
# expr1 *= expr2      - Multiplication assignment      (Is equivalent to "expr1 = parser.op((expr1) * (expr2))")
# expr1 /= expr2      - Division assignment            (Is equivalent to "expr1 = parser.op((expr1) / (expr2))")
# expr1 ~/= expr2     - Truncation division assignment (Is equivalent to "expr1 = parser.op((expr1) ~/ (expr2))")
# expr1 //= expr2     - Floor division assignment      (Is equivalent to "expr1 = parser.op((expr1) // (expr2))")
# expr1 ^/= expr2     - Ceil division assignment       (Is equivalent to "expr1 = parser.op((expr1) ^/ (expr2))")
# expr1 **= expr2     - Power assignment               (Is equivalent to "expr1 = parser.op((expr1) ** (expr2))")
# expr1 %= expr2      - Modulo assignment              (Is equivalent to "expr1 = parser.op((expr1) % (expr2))")
# expr1 >>= expr2     - Right shift assignment         (Is equivalent to "expr1 = parser.op((expr1) >> (expr2))")
# expr1 >>>= expr2    - Right shift zero assignment    (Is equivalent to "expr1 = parser.op((expr1) >>> (expr2))")
# expr1 <<= expr2     - Left shift assignment          (Is equivalent to "expr1 = parser.op((expr1) << (expr2))")
# expr1 &= expr2      - Bitwise and assignment         (Is equivalent to "expr1 = parser.op((expr1) & (expr2))")
# expr1 |= expr2      - Bitwise or assignment          (Is equivalent to "expr1 = parser.op((expr1) | (expr2))")
# expr1 ^= expr2      - Bitwise xor assignment         (Is equivalent to "expr1 = parser.op((expr1) ^ (expr2))")

# Operator precedence/associativity
# Precedence | Operator           | Associativity | Operator name
# ===========|====================|===============|================================
#  0         | (opr)              | -             | Grouping
# -----------|--------------------|---------------|--------------------------------
#  0.5       | opr1(opr2)         | -             | Function calls
# -----------|--------------------|---------------|--------------------------------
#  1         | @opr               | right-to-left | Length
#            | ^opr               |               | Deep copy
# -----------|--------------------|---------------|--------------------------------
#  2         | opr1 ** opr2       | right-to-left | Power [1]
# -----------|--------------------|---------------|--------------------------------
#  3         | +opr               | right-to-left | Positive
#            | -opr               |               | Inverse
#            | ~opr               |               | Bitwise not
#            | ▲opr               |               | Increment
#            | ▼opr               |               | Decrement
#            | !opr               |               | Not
# -----------|--------------------|---------------|--------------------------------
#  4         | opr1 * opr2        | left-to-right | Multiplication
#            | opr1 / opr2        |               | Division
#            | opr1 ~/ opr2       |               | Truncation division
#            | opr1 // opr2       |               | Floor division
#            | opr1 ^/ opr2       |               | Ceil division
#            | opr1 % opr2        |               | Modulo
# -----------|--------------------|---------------|--------------------------------
#  5         | opr1 + opr2        | left-to-right | Addition
#            | opr1 - opr2        |               | Subtraction
# -----------|--------------------|---------------|--------------------------------
#  6         | opr1 << opr2       | left-to-right | Left shift
#            | opr1 >> opr2       |               | Right shift
#            | opr1 >>> opr2      |               | Right zero shift
# -----------|--------------------|---------------|--------------------------------
#  7         | opr1 & opr2        | left-to-right | Bitwise and
# -----------|--------------------|---------------|--------------------------------
#  8         | opr1 ^ opr2        | left-to-right | Bitwsie xor
# -----------|--------------------|---------------|--------------------------------
#  9         | opr1 | opr2        | left-to-right | Bitwise or
# -----------|--------------------|---------------|--------------------------------
# 10         | opr1 <=> opr2      | left-to-right | Spaceship
#            | opr1 ~~ opr2       |               | Instance of
#            | opr1 == opr2       |               | Equals
#            | opr1 != opr2       |               | Not equals
#            | opr1 =~ opr2       |               | Matches
#            | opr1 !=~ opr2      |               | Not matches
#            | opr1 === opr2      |               | Strict equals
#            | opr1 !== opr2      |               | Strict not equals
#            | opr1 < opr2        |               | Less than
#            | opr1 > opr2        |               | Greater than
#            | opr1 <= opr2       |               | Less than or equals
#            | opr1 >= opr2       |               | Greater than or equals
# -----------|--------------------|---------------|--------------------------------
# 11         | opr1 && opr2       | left-to-right | And
# -----------|--------------------|---------------|--------------------------------
# 12         | opr1 || opr2       | left-to-right | Or
# -----------|--------------------|---------------|--------------------------------
# 13         | opr1 ?: opr2       | left-to-right | Elvis
#            | opr1 ?? opr2       |               | Null coalescing
# -----------|--------------------|---------------|--------------------------------
# 14         | opr1 ? opr2 : opr3 | right-to-left | Inline if
# -----------|--------------------|---------------|--------------------------------
# 15         | opr1 = opr2        | right-to-left | Normal assignment
#            | opr1 = opr2        |               | Translation
#            | opr1 ?= opr2       |               | Set condition assignment
#            | opr1 := opr2       |               | Set math assignment
#            | opr1 $= opr2       |               | Set operation assignment
#            | opr1 += opr2       |               | Addition assignment
#            | opr1 -= opr2       |               | Subtraction assignment
#            | opr1 *= opr2       |               | Multiplication assignment
#            | opr1 /= opr2       |               | Division assignment
#            | opr1 ~/= opr2      |               | Truncation division assignment
#            | opr1 //= opr2      |               | Floor division assignment
#            | opr1 ^/= opr2      |               | Ceil division assignment
#            | opr1 **= opr2      |               | Power assignment
#            | opr1 %= opr2       |               | Modulo assignment
#            | opr1 >>= opr2      |               | Right shift assignment
#            | opr1 >>>= opr2     |               | Right zero shift assignment
#            | opr1 <<= opr2      |               | Left shift assignment
#            | opr1 &= opr2       |               | Bitwise and assignment
#            | opr1 |= opr2       |               | Bitwise or assignment
#            | opr1 ^= opr2       |               | Bitwise xor assignment
#
# Footnotes:
# 1) The unary operators (+, -, ~, ▲, ▼, and !) have a higher binding than the power operator if they are on the right of the power operator.

# Parser functions
# parser.con(opr) # Condition
# parser.math(opr) # Math expression
# parser.op(opr) # Operator expression (Math expression & Condition)

func.println(2 && 3)
func.println(parser.con(2 && 3))
func.println(parser.math(2 && 3)) # Will crash, because it will be parses as: 2 BITWISE_AND (& 3)
func.println(parser.op(2 && 3))

func.println()
func.println(2 & 3)
func.println(parser.con(2 & 3)) # Will return 1 because "2 & 3" is parsed as text value
func.println(parser.math(2 & 3))
func.println(parser.op(2 & 3))

func.println()
func.println(0 & 3)
func.println(parser.con(0 & 3)) # Will return 1 because "2 & 3" is parsed as text value
func.println(parser.math(0 & 3))
func.println(parser.op(0 & 3))

# Parser functions can be used inside parser functions
func.println()
func.println(parser.math(4 + parser.con(abc && parser.op(1 + 3 === 4))))
# Wil be parsed as:
# 4 ADD (abc AND ((1 ADD 3) STRICT_EQUALS 4))
# 4 ADD (abc AND (4 STRICT_EQUALS 4))
# 4 ADD (abc AND 1)
# 4 ADD 1
# 5

# Spaceship operator
# $a <=> $b:
#   if $a < $b:  -1
#   if $a == $b:  0
#   if $a > $b:   1
#   if $a not comparable to $b (= every previous check returned false): null
func.println()
func.println(parser.op(1 <=> 1)) # 0
func.println(parser.op(1 <=> 2)) # -1
func.println(parser.op(2 <=> 1)) # 1
func.println(parser.op(null <=> 1)) # null
func.println(parser.op(null <=> null)) # 0
func.println(parser.op(1 <=> null)) # null

# Elvis operator
# Will be evaulate to the first operand if it evaluates to true else it will be evalute the second operand
func.println()
func.println(parser.op(1 ?: 42)) # 1
func.println(parser.op(0 ?: 42)) # 42
func.println(parser.op(\0 ?: 42)) # 42
func.println(parser.op(\? ?: 42)) # ?
func.println(parser.op(abc ?: 42)) # abc
func.println(parser.op(\e ?: 42)) # 42
func.println(parser.op(func.arrayOf() ?: 42)) # 42
func.println(parser.op(func.arrayOf(1, abc) ?: 42)) # [1, abc]
func.println(parser.op(null ?: 42)) # 42
func.println(parser.op(func.print(\e) ?: 42)) # 42 (func.print(\e) will return a void value)

# Null coalescing operator
# Will be evaulate to the first operand if it is not null and not void else it will be evalute the second operand
func.println()
func.println(parser.op(1 ?? 42)) # 1
func.println(parser.op(0 ?? 42)) # 0
func.println(parser.op(\0 ?? 42)) # \0
func.println(parser.op(\? ?? 42)) # ?
func.println(parser.op(abc ?? 42)) # abc
func.println(parser.op(\e ?? 42)) # \e
func.println(parser.op(func.arrayOf() ?? 42)) # []
func.println(parser.op(func.arrayOf(1, abc) ?? 42)) # [1, abc]
func.println(parser.op(null ?? 42)) # 42
func.println(parser.op(func.print(\e) ?? 42)) # 42 func.print(\e) will return a void value

# Inline if operator
# Will be evaulate to the second operand if the first operand evaluates to true else it will be evalute the thrid operand
func.println()
func.println(parser.op(1 ? TRUE : FALSE)) # TRUE
func.println(parser.op(0 ? TRUE : FALSE)) # FALSE
func.println(parser.op(\0 ? TRUE : FALSE)) # FALSE
func.println(parser.op(\? ? TRUE : FALSE)) # TRUE
func.println(parser.op(abc ? TRUE : FALSE)) # TRUE
func.println(parser.op(\e ? TRUE : FALSE)) # FALSE
func.println(parser.op(func.arrayOf() ? TRUE : FALSE)) # FALSE
func.println(parser.op(func.arrayOf(1, abc) ? TRUE : FALSE)) # TRUE
func.println(parser.op(null ? TRUE : FALSE)) # FALSE
func.println(parser.op(func.print(\e) ? TRUE : FALSE)) # FALSE func.print(\e) will return a void value

func.println()

# Assignment operators
# Normal assignment
$a = 42
func.println($a)

func.println()

# Set condition assignment
$test ?= 1 || 0
func.println($test)

$test ?= 1 && 0
func.println($test)

func.println()

# Set math assignment
$test := 2 + 3
func.println($test)

$test := 2 ** 3
func.println($test)

$test := 10 ~/ 4
func.println($test)

$test := -10 ~/ 4
func.println($test)

func.println()

# Set operation assignment
$test $= func.rand() % 11 ?: 42 # Rvalue will be parsed as operation expression "parser.op()"
func.println($test)

$test $= 1 && 0 || 1 - 1 ?: 30
func.println($test)

$test $= (func.randChoice(null, 0, 1, 2, abc) ?? text-) + 30
func.println($test)

func.println()

$test $= 0 ?: null ?: 0.0
func.println($test) # 0.0
$test $= 0 ?: null ?: 3
func.println($test) # 3
$test $= 0 ?: 2 ?: 0.0
func.println($test) # 2
$test $= 0 ?: 2 ?: 3
func.println($test) # 2
$test $= 1 ?: null ?: 0.0
func.println($test) # 1
$test $= 1 ?: null ?: 3
func.println($test) # 1
$test $= 1 ?: 2 ?: 0.0
func.println($test) # 1
$test $= 1 ?: 2 ?: 3
func.println($test) # 1

func.println()

$a $= 42 - 20 * 2
func.println($a)

# Math assignments (Rvalue will be parsed as math expression "parser.op()")
$a += (40 - 23) // 2 # Addition assignment
func.println($a)

$a -= 2 # Subtract assignment
func.println($a)

$a *= 3 + 1 # Multiplication assignment
func.println($a)

$a /= 3 # Division assignment
func.println($a)

$a //= 3 # Floor division assignment
func.println($a)

$a **= 8 # Power assignment
func.println($a)

$a = func.int($a) # Convert $a to integer

$a %= 250 # Modulo assignment
func.println($a)

$a >>= 2 # Right shift assignment
func.println($a)

$a >>>= 1 # Right zero shift assignment
func.println($a)

$a <<= 1 # Left shift assignment
func.println($a)

$a &= 250 # Bitwise and assignment
func.println($a)

$a |= 15 # Bitwise or assignment
func.println($a)

$a ^= 43 # Bitwise xor assignment
func.println($a)

func.println()

# Evaluation order
# Function pointer is only for output, Function pointers: See [05_functionPointer.lang]
fp.printAndRet = ($name, $num) -> {
	func.println(Evaluation: $num ($name))
	
	return $num
}

# Left-to-right vs right-to-left operators with 1 operator
func.println()
func.println(15 / 3:)
func.println(Output: parser.op(printAndRet(l, 15) / printAndRet(r, 3)))
func.println()
func.println(15 ** 3:)
func.println(Output: parser.op(printAndRet(l, 15) ** printAndRet(r, 3)))
func.println()

# Left-to-right vs right-to-left operators with 2 operators
func.println()
func.println(10 / 5 / 2:)
func.println(Output: parser.op(printAndRet(l, 10) / printAndRet(m, 5) / printAndRet(r, 2)))
func.println()
func.println(10 / (5 / 2):)
func.println(Output: parser.op(printAndRet(l, 10) / (printAndRet(m, 5) / printAndRet(r, 2))))
func.println()
func.println(10 ** 5 ** 2:)
func.println(Output: parser.op(printAndRet(l, 10) ** printAndRet(m, 5) ** printAndRet(r, 2)))
func.println()
func.println((10 ** 5) ** 2:)
func.println(Output: parser.op((printAndRet(l, 10) ** printAndRet(m, 5)) ** printAndRet(r, 2)))
func.println()

# Conditional vs bitwise AND/OR
func.println()
func.println(1 || 0:)
func.println(Output: parser.op(printAndRet(l, 1) || printAndRet(r, 0)))
func.println()
func.println(0 || 1:)
func.println(Output: parser.op(printAndRet(l, 0) || printAndRet(r, 1)))
func.println()
func.println(1 && 0:)
func.println(Output: parser.op(printAndRet(l, 1) && printAndRet(r, 0)))
func.println()
func.println(0 && 1:)
func.println(Output: parser.op(printAndRet(l, 0) && printAndRet(r, 1)))
func.println()
func.println(1 | 0:)
func.println(Output: parser.op(printAndRet(l, 1) | printAndRet(r, 0)))
func.println()
func.println(0 | 1:)
func.println(Output: parser.op(printAndRet(l, 0) | printAndRet(r, 1)))
func.println()
func.println(1 & 0:)
func.println(Output: parser.op(printAndRet(l, 1) & printAndRet(r, 0)))
func.println()
func.println(0 & 1:)
func.println(Output: parser.op(printAndRet(l, 0) & printAndRet(r, 1)))
func.println()

# Null coalescing and elvis and inline if
func.println()
func.println(abc ?? r:)
func.println(Output: parser.op(printAndRet(l, abc) ?? printAndRet(r, r)))
func.println()
func.println(0 ?? r:)
func.println(Output: parser.op(printAndRet(l, 0) ?? printAndRet(r, r)))
func.println()
func.println(null ?? r:)
func.println(Output: parser.op(printAndRet(l, null) ?? printAndRet(r, r)))
func.println()
func.println(abc ?: r:)
func.println(Output: parser.op(printAndRet(l, abc) ?: printAndRet(r, r)))
func.println()
func.println(0 ?: r:)
func.println(Output: parser.op(printAndRet(l, 0) ?: printAndRet(r, r)))
func.println()
func.println(null ?: r:)
func.println(Output: parser.op(printAndRet(l, null) ?: printAndRet(r, r)))
func.println()
func.println(abc ? m : r:)
func.println(Output: parser.op(printAndRet(l, abc) ? printAndRet(m, m) : printAndRet(r, r)))
func.println()
func.println(0 ? m : r:)
func.println(Output: parser.op(printAndRet(l, 0) ? printAndRet(m, m) : printAndRet(r, r)))
func.println()
func.println(null ? m : r:)
func.println(Output: parser.op(printAndRet(l, null) ? printAndRet(m, m) : printAndRet(r, r)))
