lang.name = Useful stuff
lang.version = v1.0.0

# Line continuation
{
	func.printTerminal(3, abc-\
test) # Will print "abc-test", if "\" is at end of line and outside of a multiline text, the line will be split (It must be the end of the line, comments may not come after "\")
# The leading whitespaces of a line after "\" will be parsed
	
	func.printTerminal(4, abc-\
{{{
test
}}})
	
func.printTerminal(5, abc-{{{
test
}}}\
abc)
	
func.printTerminal(6, abc-{{{
test\
}}})
}

func.printTerminal(-1, \n\n\n)

# Multiline comments
{
	# Comment \
	2nd line
	
	# Comment \
	func.printTerminal(-1, test) # In comment
	func.printTerminal(-1, test) # Not in comment
	
	# Comment \
	2nd line \
	3rd line
	
	# Comment {{{
		2nd line
		3rd line
	}}} - 4th line \
	5th line
	
	# Comment \
	2nd line {{{
		3rd line
	}}} - 4th line
}

func.printTerminal(-1, \n\n\n)

# Custom IO functions
{
	con.if(func.isTerminalAvailable())
		fp.input = func.readTerminal
		fp.print = func.printTerminal
		fp.error = ($text...) -> func.printTerminal(5, $text)
	con.else
		fp.input = ($text...) -> {
			con.if($text)
				func.print($text: )
			con.else
				func.print(Input: )
			con.endif
			return func.input()
		}
		fp.print = ($lvl, $text...) -> func.println($text)
		fp.error = func.errorln
	con.endif
	
	$input = fp.input(Test)
	fp.print(1, Input: $input)
	fp.print(2, varars, test)
	fp.error(test error)
	fp.error(test, error, with, varargs)
	
	$input = fp.input() # Empty input message
	fp.print(1, Input: $input)
}

func.printTerminal(-1, \n\n\n)

# Advanced conditions
{
	# XOR: (CONDITION) != (CONDITION)
	func.printTerminal(2, XOR:)
	func.printTerminal(1, (1 > 42) != (1 > 42) = func.condition({{{(1 > 42) != (1 > 42)}}})) # 0
	func.printTerminal(1, (1 > 42) != (1 < 42) = func.condition({{{(1 > 42) != (1 < 42)}}})) # 1
	func.printTerminal(1, (1 < 42) != (1 > 42) = func.condition({{{(1 < 42) != (1 > 42)}}})) # 1
	func.printTerminal(1, (1 < 42) != (1 < 42) = func.condition({{{(1 < 42) != (1 < 42)}}})) # 0
	
	# NXOR: (CONDITION) == (CONDITION)
	func.printTerminal(2, \nNXOR:)
	func.printTerminal(1, (1 > 42) != (1 > 42) = func.condition({{{(1 > 42) == (1 > 42)}}})) # 1
	func.printTerminal(1, (1 > 42) != (1 < 42) = func.condition({{{(1 > 42) == (1 < 42)}}})) # 0
	func.printTerminal(1, (1 < 42) != (1 > 42) = func.condition({{{(1 < 42) == (1 > 42)}}})) # 0
	func.printTerminal(1, (1 < 42) != (1 < 42) = func.condition({{{(1 < 42) == (1 < 42)}}})) # 1
}

func.printTerminal(-1, \n\n\n)

# "Returning" of multiple values
{
	# "Return" is also possible with the pointer dereferencing "$*ptr"
	
	# With call by value
	{
		# $column and $row are var pointers
		fp.convertIndexToCoords = ($index, $COLUMN_COUNT, $column, $row) -> {
			$*column = func.modi($index, $COLUMN_COUNT)
			$*row = func.divi($index, $COLUMN_COUNT)
		}
		$index = 42
		$COLUMN_COUNT = 12
		$column = $row = null
		fp.convertIndexToCoords(42, 12, $[column], $[row])
		func.printTerminal(-1, $index with $COLUMN_COUNT columns = column $column, row $row)
	}
	
	func.printTerminal(-1, \n)
	
	# With call by pointer
	{
		fp.convertIndexToCoords = ($index, $COLUMN_COUNT, $[column], $[row]) -> {
			# "$column" and "$row" are pointers to the corresponding arguments
			$*column = func.modi($index, $COLUMN_COUNT)
			$*row = func.divi($index, $COLUMN_COUNT)
		}
		$index = 42
		$COLUMN_COUNT = 12
		$column = $row = null
		# Two pointers are created for $column" and "$row" during the call process
		fp.convertIndexToCoords(42, 12, $column, $row)
		func.printTerminal(-1, $index with $COLUMN_COUNT columns = column $column, row $row)
	}
}
