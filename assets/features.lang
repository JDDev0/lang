# Lang data
lang.name = Features
lang.version = v1.0.0

# Lang content
# Translations examples ("translation key" = "translation value")
ui.button.ok = Ok
ui.button.canel = Cancel

{ # "Block" start (Is ignored by compiler (only for readability)
# Trailing and leading Whitespaces are ignored by compiler (use \s for trailing Space)
	# Variable assignment (" = ", Spaces are important)
	$a = Hello\s
	$b =  World
} # "Block" end (Variables declared in block will be available after block)

# Text concatenation
{
	hello.world = $a$b	
	
	$c = $a-$b
	# \n: escape sequence for "new line"
	$c = ---Test---\n$c
}

# Function pointer
{
	# Loops
	{
		# For
		func.printTerminal(2, Simple for loop test!)
		fp.printColor = ($i) -> {
			# func.subi(a, b) -> a - b for int
			$i = func.subi($i, 1) #[0, 7] for repeat will be changed to [-1, 6]
			
			# func.printTerminal(Log Level [-1 - 6] (= Color), Text)
			func.printTerminal($i, $i: $c)
		} # Variables declared or changed in block won't be available after block

		# Simple for loop (Calls first parameter (Function pointer) with (0)
		#   to (count - 1)
		func.repeat(fp.printColor, 8)
		
		# While (New in v0.2.0)
		func.printTerminal(2, While loop test!)
		$num = 50
		fp.printFunc = () -> {
			func.printTerminal(4, $num)
			$num = func.subi($num, 1)
			func.printTerminal(3, $num)
			func.copyAfterFP($[num], $[num])
		}
		# One-line function pointer definition (New in v0.2.0)
		fp.test = () -> return parser.con($num > 41)
		
		func.repeatWhile(fp.printFunc, fp.test)
		
		# Until (New in v0.2.0)
		func.printTerminal(2, Until loop test!)
		$win = 0
		$num = func.modi(func.rand(), 10)
		fp.printFunc = () -> {
			$guess = func.addi(func.modi(func.rand(), 10))
			con.if($guess < $num)
				func.printTerminal(3, The number is larger than $guess!)
			con.elif($guess > $num)
				func.printTerminal(3, The number is smaller than $guess!)
			con.else
				$win = 1
				func.copyAfterFP($[win], $[win])
				func.printTerminal(2, You got the number $guess!)
			con.endif
		}
		fp.test = () -> return $win
		# While loop (Calls first parameter (Function pointer) while second
		#   parameter returns true)
		func.repeatUntil(fp.printFunc, fp.test)
	}

	# Function pointer with return value
	fp.test = () -> {
		func.printTerminal(4, TEXT)
		return 42-TEst
		func.printTerminal(5, TEXT) # Will never be executed, because it comes
			                        # after an return statement
	}
	func.printTerminal(3, fp.test())
	fp.test2 = () -> {
		func.printTerminal(1, TEXT)
		return # Return without value
		func.printTerminal(2, TEXT) # Will never be executed, because it comes
			                        # after an return statement
	}
	func.printTerminal(3, fp.test2())
	
	# Use values that are defined after function pointer definition
	fp.print42 = ($lvl) -> {
		func.printTerminal($lvl, $test42)
		func.printError() # No error should occur:
		                  #   If the variable $test42 is not defined:
		                  #     "$test42" will be printed
	}
	fp.print42(3)
	# Value definition
	$test42 = TEST the number 42
	fp.print42(2)
	
	# Recursion
	fp.fac = ($num) -> {
		con.if($num < 2)
			return 1
		con.endif
		
		# Recursive call: fp.fac(func.subi($num, 1))
		return func.mull($num, fp.fac(func.subi($num, 1)))
	}
	fp.printFac = ($i) -> {
		func.printTerminal(3, Factorial of $i is fp.fac($i)!)
	}
	func.repeat(fp.printFac, 25) # Long precision is not enough for 21! and beyond
	
	# Indirect recursion (Uses variable definition after function pointer definition)
	fp.a = ($a) -> {
		return $a - fp.b(func.subi($a, 2))
	}
	fp.b = ($a) -> {
		con.if($a < 0)
			return END
		con.endif
		
		return $a - fp.a(func.addi($a, 1))
	}
	func.printTerminal(4, fp.a(10))
	
	# FunctionPointer as return value
	{
		fp.function = ($a, $b) -> {
			func.printTerminal($a, $b)
		}
		fp.retFP = () -> {
			return fp.function
		}
		
		func.printTerminal(5, fp.retFP) # Will print "fp.retFP"
		func.printTerminal(5, fp.retFP()) # Will print "fp.function"
		fp.retFP()(-1, TESTED) # Call of returend function pointer
		
		# Changing of returned function pointer is not possible
		fp.retFP() = () -> {
			func.printTerminal(2, TAMPERED!)
		}
		fp.retFP()(1, 1)
		{ # Bracket is only for parser (Because "}" closed a block, but ") -> {" won't open a block
		
		# Funny things you can do with this
		fp.function = ($a) -> {
			func.printTerminal(1, $a)
		}
		fp.retFP = ($con) -> {
			func.printTerminal(1, fp.retFP was called!)
			
			con.if($con)
				return fp.retFP
			con.endif
			
			return fp.function
		}
		fp.retFP(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(1)(0)(1)
	}
	
	# FunctionPointer argument duplication
	# If not enough arguments are provided, the compiler will copy the
	#   last argument given. If no argument was given, all variables will be empty
	# If too many arguments are given, the compiler will ignore them
	fp.manyArgs = ($a, $b, $c, $d, $e, $f, $g, $h) -> {
		func.printTerminal(-1, $a)
		func.printTerminal(0, $b)
		func.printTerminal(1, $c)
		func.printTerminal(2, $d)
		func.printTerminal(3, $e)
		func.printTerminal(4, $f)
		func.printTerminal(5, $g)
		func.printTerminal(6, $h)
		func.printTerminal(-1, -----------------)
	}
	fp.manyArgs()
	fp.manyArgs(A)
	fp.manyArgs(A, B)
	fp.manyArgs(A, B, C)
	fp.manyArgs(A, B, C, D)
	fp.manyArgs(A, B, C, D, E)
	fp.manyArgs(A, B, C, D, E, F)
	fp.manyArgs(A, B, C, D, E, F, G)
	fp.manyArgs(A, B, C, D, E, F, G, H)
	fp.manyArgs(A, B, C, D, E, F, G, H, I)
	
	lang.errorOutput = 0 # Disable error ouput
	
	# Coping of functions
	{
		fp.a = ($i) -> {
			func.printError($i)
		}
		func.repeat(fp.a, 10)
		
		func.printTerminal(1, \s\n\s)
		
		# Coping of function pointer
		fp.b = fp.a
		func.repeat(fp.b, 10)
		
		func.printTerminal(1, \s\n\s)
		
		# Coping of predefined functions (New in v0.2.0)
		fp.c = func.printError
		func.repeat(fp.c, 10)
		
		func.printTerminal(1, \s\n\s)
	}
	
	lang.errorOutput = 1 # Reenable error ouput
}

# \$ -> escape sequence for $
# \s is needed, because leading whitespaces are behind the argument separator
# will be removed in every function argument
func.printTerminal(0, \s\n\n\n\n\$a--------\$\n\n\n )

lang.errorOutput = 0 # Disable error ouput

# Error handling
{
	# Will print no error since errno is 0
	func.printError()
	
	# divl: Division for long
	# Will produce "Dividing by 0 error"
	$a = func.divl(1, 0)
	
	# Will print an error and resets errno to 0
	# Parameter is not needed
	func.printError(TEXT)
	
	# Will print no error since errno is 0
	func.printError()
	
	# Will produce an error (because $LANG vars are not modifiable by code)
	$LANG_VERSION = v42
	# Get errno
	$errno = $LANG_ERRNO
	# Get error message (Will set errno to 0)
	$errtxt = func.getErrorText()
	func.printTerminal(4, $errno: $errtxt)
	
	# Will print no error since errno is 0
	func.printError()
	
	func.printTerminal(5, \s\n\n\n\n\n-----------------)
	
	# User input (Implementation by compiler is optional!
	# If it isn't implemented, an error will occur (function will return ("Error")!)
	$in = func.readTerminal(INPUT please:)
	
	#func.strlen(TEXT) returns the length of the provided text
	$len = func.strlen($in)
	
	# Check if input is supported
	con.if($LANG_ERRNO != 0)
		func.printError(Input is not supported)
	con.elif($len == 0)
		func.printTerminal(5, You haven't provide any input!)
	con.else
		# Do something with input
		func.printTerminal(2, Thanks for your $len character input: "$in"!)
	con.endif
	
	user.setting.1 = func.readTerminal(Enter setting 1:)
}

lang.errorOutput = 1 # Reenable error ouput

# Arrays
{
	# Print array function pointer
	fp.printArray = (&a) -> {
		func.printTerminal(2, \s\nArray:)
		$i = 0
		fp.printElement = ($ele) -> {
			func.printTerminal(2, Array[$i] \= $ele)
			
			# Set Index
			$i = func.addi($i, 1)
			# $[i] -> var pointer
			# func.copyAfterFP(callerVar, functionVar)
			# this function copies the value of an function internal variable
			# to a variable outside of the function
			func.copyAfterFP($[i], $[i])
		}
		
		# Execute function pointer with ($ele) for each element
		func.arrayForEach(&arr, fp.printElement)
	}
	
	# func.arrayMake(ArrayName, ArraySize)
	func.arrayMake(&arr, 10)
	fp.printArray(&arr)
	
	# Sets all element to a value
	func.arraySetAll(&arr, 42)
	fp.printArray(&arr)
	
	# Sets all element to different value
	func.arraySetAll(&arr, 0, 1, 2, 3, 4, 5, 6, 42, 8, 10)
	fp.printArray(&arr)
	
	# Sets a element to a value
	func.arraySet(&arr, 5, TEST)
	fp.printArray(&arr)
	
	# Gets a value of an array
	$ele = func.arrayGet(&arr, 5)
	func.printTerminal(3, Value at 5th index: $ele)
	
	# Array index out of bounds
	$ele = func.arrayGet(&arr, 10)
	func.printTerminal(-1, This Language starts with the 0th index)
	
	# Gets all values of array
	$eles = func.arrayGetAll(&arr)
	func.printTerminal(3, $eles)
	
	# Gets a random element of an array
	$ele = func.randChoice(&arr)
	func.printTerminal(3, Value at a random index: $ele)
	
	# Delete all values from array
	func.arrayDelete(&arr)
	fp.printArray(&arr)
	
	# Clears the array data from RAM
	func.arrayClear(&arr)
	fp.printArray(&arr)
	
	# Gets a random TEXT from an TEXT list
	$txt = func.randChoice(TEST, 1, 42, THIS is a Text!, $a - $b, $c)
	func.printTerminal(-1, $txt)
}

# String functions
{
	# toUpper and toLower
	$test = TesT for this string function
	func.printTerminal(2, func.toUpper($test))
	func.printTerminal(2, func.toLower($test))
	
	# Substring
	$txt = This is a test!
	$test = func.substring($txt, 10)
	func.printTerminal(2, $test)
	$test = func.substring($txt, 0, 6)
	func.printTerminal(2, $test)
	
	# TEXT concatenation 2 (Be CAREFUL: if $tests exists it will be printed, if
	# $tests doesn't exist and $test exists than $test with a s at the end will
	# be printed)
	func.printTerminal(2, $tests)
	
	# Splits a string
	$csv = A;B;C;E;1;42
	func.split(&splited, $csv, ;)
	func.printTerminal(2, func.arrayGetAll(&splited))
	# Maximal n (= last argument) spilts
	func.split(&splited, $csv, ;, 2)
	func.printTerminal(2, func.arrayGetAll(&splited))
}

# Utility
{
	# Variables
	{
		# Empty variable
		$a
		func.printTerminal(5, $a)
		
		# Redirecting of var pointer
		$var = T
		func.printTerminal(4, $var)
		func.printTerminal(4, $[var])
		func.printTerminal(4, $[[var]])
		func.printTerminal(4, $[[[var]]])
		
		$[[var]] = Not T # Modified the pointer to the var pointer
		func.printTerminal(4, $var)
		func.printTerminal(4, $[var])
		func.printTerminal(4, $[[var]])
		func.printTerminal(4, $[[[var]]])
	}
	
	# Condition function (New in v0.2.0) [func.condition is deprecated -> replaced with parser.con]
	{
		# parser.con returns 1 if condition is true else 0
		func.printTerminal(2, 0 and 5)
		func.printTerminal(3, parser.con(0 == 5))
		func.printTerminal(3, parser.con(0 != 5))
		func.printTerminal(3, parser.con(0 < 5))
		func.printTerminal(3, parser.con(0 > 5))
		func.printTerminal(3, parser.con(0 <= 5))
		func.printTerminal(3, parser.con(0 >= 5))
		func.printTerminal(2, 5 and 5)
		func.printTerminal(3, parser.con(5 == 5))
		func.printTerminal(3, parser.con(5 != 5))
		func.printTerminal(3, parser.con(5 < 5))
		func.printTerminal(3, parser.con(5 > 5))
		func.printTerminal(3, parser.con(5 <= 5))
		func.printTerminal(3, parser.con(5 >= 5))
		
		# Be careful:
		# Will return 0, because (42 == 42) is executed first and
		#   will be replaced with 1, then (1 == 42) will be checked
		#   and will be repelaced with 0
		$a = 42
		$b = 42
		$c = 42
		func.printTerminal(4, parser.con($a == $b == $c))
		# But ($a == $b == 1) will be true
		func.printTerminal(4, parser.con($a == $b == 1))
		# Use following to check if $a and $b and $c are the same:
		func.printTerminal(3, parser.con($a == $b && $b == $c))
	}
	
	# Advanced conditions
	{
		func.printTerminal(4, parser.con(1 || (1 && 0))) #1
		func.printTerminal(4, parser.con(1 || 1 && 0)) #1
		func.printTerminal(4, parser.con((1 || 1) && 0)) #0
		
		func.printTerminal(4, parser.con(1 && (0 || 1))) #1
		func.printTerminal(4, parser.con(1 && 0 || 1)) #1
		func.printTerminal(4, parser.con((1 && 0) || 1)) #1
		
		func.printTerminal(4, parser.con(0 && (1 || 0))) #0
		func.printTerminal(4, parser.con(0 && 1 || 0)) #0
		func.printTerminal(4, parser.con((0 && 1) || 0)) #0
		
		func.printTerminal(4, parser.con(0 && (0 || 1))) #0
		func.printTerminal(4, parser.con(0 && 0 || 1)) #1
		func.printTerminal(4, parser.con((0 && 0) || 1)) #1
		
		func.printTerminal(4, parser.con(!(0 && (0 || 1)))) #1
		func.printTerminal(4, parser.con(!(0 && 0 || 1))) #0
		func.printTerminal(4, parser.con(!((0 && 0) || 1))) #0
		
		func.printTerminal(4, parser.con(!0 && (0 || 1))) #1
		func.printTerminal(4, parser.con(!0 && 0 || 1)) #1
		func.printTerminal(4, parser.con(!(0 && 0) || 1)) #1
	}

	# Returns the folder where the lang is located
	func.printTerminal(4, $LANG_PATH)

	# \# -> escape sequence for #
	\#test.value = test

	# Clear all variables and arrays
	$a = TEST
	$b = YES!
	func.printTerminal(-1, $a: $b)

	func.clearAllVars()

	func.printTerminal(-1, $a: $b)
	
	# Sleep
	func.printTerminal(-1, 0)
	func.sleep(1000)
	func.printTerminal(0, 1)
	func.sleep(1)
	func.printTerminal(1, 2)
	func.sleep(1)
	func.printTerminal(2, 3)
	fp.printColor = ($i) -> {
		$i2 = func.subi($i, 1)
		func.printTerminal($i2, $i2: $i)
		
		# Sleeps 100 ms
		func.sleep(100)
	}
	func.repeat(fp.printColor, 8)
	
	# Get Translation value
	lang.value = TESTed 42
	func.printTerminal(2, func.getTranslationValue(lang.value))
}

# New in version v0.2.0
{
	# Clear a var
	{
		func.printTerminal(1, $x) # Prints: "$x"
		
		$x
		func.printTerminal(1, $x) # Prints: "null"
		
		$x = 42
		func.printTerminal(1, $x) # Prints: "42"
		
		func.clearVar($[x])
		func.printTerminal(1, $x) # Prints: "$x"
	}
	
	lang.errorOutput = 0 # Disable error ouput
	
	# Final variables test
	{
		$a = DO NOT modify!
		# Makes $a final
		func.makeFinal($[a])
		
		$a = I have modified you! # Will result in an error
		func.printTerminal(2, $a)
		func.printError()
		
		$a # Will also result in an error
		func.printTerminal(2, $a)
		func.printError()
		
		$b = $a # No Error
		$b = TEST # Also no error
		func.printTerminal(2, $a: $b)
		func.printError()
		
		fp.test = () -> {
			# No error, because $a is an local variable of the function
			$a = 100
			func.printTerminal(2, $a)
			func.printError()
			
			# Will also result in an error
			func.copyAfterFP($[a], $[a])
		}
		fp.test()
		func.printTerminal(2, $a)
		func.printError()
		
		fp.test = () -> {
			func.printTerminal(2, TESTED!)
		}
		# Makes fp.test final
		func.makeFinal(fp.test)
		fp.test() # Will produce no error
		func.printError()
		
		fp.test = () -> { # Will result in an error
			func.printTerminal(5, Modifyed!)
		}
		fp.test()
		func.printError()
		
		# func.clearVar can only remove non final vars
		func.clearVar(fp.test) # Will result in an error
		fp.test()
		func.printError()
		
		# Only way to remove final vars
		func.clearAllVars()
		
		$a # Will produce no error
		func.printTerminal(2, $a)
		func.printError()
		
		$a = New variable # Will also produce no error
		func.printTerminal(2, $a)
		func.printError()
	}
	
	lang.errorOutput = 1 # Reenable error ouput
	
	# Bitwise operations
	{
		func.printTerminal(2, func.andi(84, 42))
		func.printTerminal(2, func.ori(84, 42))
		func.printTerminal(2, func.xori(84, 42))
		func.printTerminal(2, func.noti(84))
		func.printTerminal(2, func.lshifti(84, 1))
		func.printTerminal(2, func.rshifti(84, 1))
		func.printTerminal(2, func.rzshifti(84, 1))
		func.printTerminal(2, func.rshifti(-84, 1))
		func.printTerminal(2, func.rzshifti(-84, 1))
		
		func.printTerminal(2, func.andl(84, 42))
		func.printTerminal(2, func.orl(84, 42))
		func.printTerminal(2, func.xorl(84, 42))
		func.printTerminal(2, func.notl(84))
		func.printTerminal(2, func.lshiftl(84, 1))
		func.printTerminal(2, func.rshiftl(84, 1))
		func.printTerminal(2, func.rzshiftl(84, 1))
		func.printTerminal(2, func.rshiftl(-84, 1))
		func.printTerminal(2, func.rzshiftl(-84, 1))
	}
}

# New in version v1.0.0
{
	# New escape sequences
	{
		# Old: \n \s \$ \#
		
		# \0: Ascii null byte
		func.printTerminal(1, A null byte: "\0"!)
		
		# \r: Carriage return
		func.printTerminal(1, A carriage return: "\r"!)
		
		# \f: Form feed
		func.printTerminal(1, A form feed: "\f"!)
		
		# \e: Empty text (Text of length 0)
		func.printTerminal(1, An empty text: "\e"!)
		# Used for function calls where an empty text is needed instead of a VOID value
		
		
		# \b: Form feed
		func.printTerminal(1, A backspace: "\b"!)
		
		# \t: Horizontal tab
		func.printTerminal(1, A horizontal tab: "\t"!)
		
		# \&: &
		func.printTerminal(1, An ampersand: "\&")
		
		# \,: ,
		fp.a = ($text) -> func.printTerminal(3, $text)
		fp.a(A test text without escaped comma: ",")
		fp.a(A test text with escaped comma: "\,")
		# Comma must not be escaped if $text was an text varargs parameter
		
		# \(: (
		# \): )
		# Used if a text in a function call contains a not equals amount of "(" and ")"
		
		# \.: .
		# \{: {
		# \}: }
		# \=: =
		# \<: <
		# \>: >
		# \+: +
		# \-: -
		# \/: /
		# \*: *
		# \%: %
		# \|: |
		# \~: ~
		# \^: ^
		# \?: ?
		# \:: :
		# \▲: ▲
		# \▼: ▼
		# \\: \
		
		# \!: Force node split
		# Will force the LangParse to split the current node at this possition
		func.printTerminal(4, func.printTerminal(2, test))
		func.printTerminal(4, func\!.printTerminal(2, test))
		# "func" will be parsed as TextNode and ".printTerminal" will be parsed as text node too
	}
	
	func.println()
	
	# Standard input/output/error functions
	{
		$var = Test Value
		func.print(ABC)
		func.println()
		func.println($var)
		func.println(func.print)
		
		# Will not be displayed in the TermIO-Control window
		func.error(ABC)
		func.errorln()
		func.errorln($var)
		func.errorln(func.print)
		
		# Input must be entered in the TermIO-Control window command text field
		$input = func.readTerminal(Should read from Standard input?\nSimply type something in the command text field and hit <ENTER>.)
		con.if($input)
			$test = func.input()
			func.printTerminal(1, $test)
			
			$test = func.input(10)
			func.printTerminal(1, $test)
		con.endif
	}
	
	func.println()
	
	# Multiple assignments in one line
	{
		$a = $b = ABC # Normal multi assignment
		func.printTerminal(1, $a)
		func.printTerminal(1, $b)
		
		$a = $b = $c = $aDEF # Normal multi assignment
		func.printTerminal(1, $\!a: $a)
		func.printTerminal(1, $\!b: $b)
		func.printTerminal(1, $\!c: $c)
		
		abc.test = $d = func.rand() # Multi assignment with translation key
		func.printTerminal(1, abc.test: func.getTranslationValue(abc.test))
		func.printTerminal(1, $\!d: $d)
		
		$e = abc.test2 = func.rand() # Translation key must be first else it will be interpretet as normal text
		func.printTerminal(1, abc.test2: func.getTranslationValue(abc.test2))
		func.printTerminal(1, $\!e: $e)
		
		$a = $b \= $c # Set $a to $b = $c
		func.printTerminal(1, $\!a: $a)
		func.printTerminal(1, $\!b: $b)
		func.printTerminal(1, $\!c: $c)
		
		$a = $a \= 123 # Set $a to $a = 123
		func.printTerminal(1, $\!a: $a)
		
		$a = $b = # Empty assignment is not allowed; would set $a to $b =
		func.printTerminal(1, $\!a: $a)
		
		fp.test1 = fp.test2 = ($test) -> func.printTerminal(1, $test)
		fp.test1(abc)
		fp.test2(abc)
	}
	
	func.println()
	
	lang.errorOutput = 0 # Disable error ouput
	
	# Varargs
	{
		# Text varargs
		fp.testTextVarArgs = ($lvl, $args...) -> {
			func.printTerminal(5, \nFrom "fp.testTextVarArgs")
			func.printTerminal($lvl, $args)
			func.printError()
		}
		fp.testTextVarArgs()
		fp.testTextVarArgs(1)
		fp.testTextVarArgs(1, 2)
		fp.testTextVarArgs(1, 2, 3)
		fp.testTextVarArgs(1, 2, 3, 4)
		fp.testTextVarArgs(1, 2, 3, 4, 5)
		fp.testTextVarArgs(1, 2, 3, 4, 5, 6)
		
		# Array varargs
		fp.testArrayVarArgs = ($lvl, &args...) -> {
			func.printTerminal(5, \nFrom "fp.testArrayVarArgs")
			func.printTerminal($lvl, &args)
			func.printError()
			func.printTerminal($lvl, func.arrayGetAll(&args))
			func.printError()
			func.printTerminal($lvl, func.arrayLength(&args))
			func.printError()
		}
		fp.testArrayVarArgs()
		fp.testArrayVarArgs(1)
		fp.testArrayVarArgs(1, 2)
		fp.testArrayVarArgs(1, 2, 3)
		fp.testArrayVarArgs(1, 2, 3, 4)
		fp.testArrayVarArgs(1, 2, 3, 4, 5)
		fp.testArrayVarArgs(1, 2, 3, 4, 5, 6)
	}
	
	lang.errorOutput = 1 # Reenable error ouput
	
	func.println()
	
	# Pointer dereferencing
	{
		$a = 42
		$ptr = $[a]
		func.printTerminal(3, $a) # 42
		func.printTerminal(3, $*a) # null
		func.printTerminal(3, $*ptr) # 42
		func.printTerminal(3, $**ptr) # null
		$*ptr = 10 # Will set "$a" to 10
		func.printTerminal(3, $a) # 10
		
		$a = 42
		func.printTerminal(3, $a) # 42
		func.printTerminal(3, $*a) # null
		
		$a = 42
		$ptr = $[a]
		$ptr2 = $[ptr]
		$ptr3 = $[[a]]
		func.printTerminal(3, $a) # 42
		func.printTerminal(3, $**ptr2) # 42
		func.printTerminal(3, $**ptr3) # 42
		$**ptr2 = 10 # Will set "$a" to 10
		func.printTerminal(3, $a) # 10
		
		$a = 42
		func.printTerminal(3, $a) # 42
		func.printTerminal(3, $[a]) # VP -> {42}
		func.printTerminal(3, $*a) # null
		func.printTerminal(3, $*[a]) # 42
		func.printTerminal(3, $*[[a]]) # VP -> {42}
		func.printTerminal(3, $**[[a]]) # 42
		
		$pointer
		func.printTerminal(3, $*pointer) # Will print null
		
		func.clearVar($[pointer]) # Undefine $pointer
		func.printTerminal(3, $pointer) # Will print "$*pointer", because "$pointer" is not defined
	}
	
	func.println()
	
	# Loop statements
	{
		func.printTerminal(2, con.while loop test!)
		$num = 50
		con.while($num > 41)
			func.printTerminal(4, $num)
			$num = func.subi($num, 1)
			func.printTerminal(3, $num)
		con.endloop
		
		func.printTerminal(2, con.until loop test!)
		$win = 0
		$num = func.modi(func.rand(), 10)
		con.until($win)
			$guess = func.addi(func.modi(func.rand(), 10))
			con.if($guess < $num)
				func.printTerminal(3, The number is larger than $guess!)
			con.elif($guess > $num)
				func.printTerminal(3, The number is smaller than $guess!)
			con.else
				$win = 1
				
				func.printTerminal(2, You got the number $guess!)
			con.endif
		con.endloop
		
		func.printTerminal(2, con.repeat loop test!)
		$i
		con.repeat($[i], 10)
			func.printTerminal(4, $i)
		con.endloop
		func.printTerminal(3, After repeat: $i)
		
		con.repeat(null, 5)
			func.printTerminal(2, $i)
		con.endloop
		
		# Else block (Will be executed if the loop body was not executed at all)
		con.repeat(null, 0)
			func.printTerminal(2, $i)
		con.else
			func.println(ELSE-Block)
		con.endloop
	}
	
	func.println()
	
	# Format functions
	{
		# func.format(FORMAT, VARARGS) # Returns TEXT
		# func.printf(FORMAT, VARARGS) # No newline
		# func.errorf(FORMAT, VARARGS) # No newline
		
		# FORMAT:
		# - Format sequences:
		#   - %% # % sign
		#   - %d # Integer number
		#   - %f # Floating point number
		#   - %s # TEXT value
		#   - %t # Translation value of a translation key
		# - Format arguments:
		#   - %<num>  # For: d, f, s, t # Size [Padding with spaces]
		#   - %-<num> # For: d, f, s, t # Size [left-justify]
		#   - %0<num> # For: d, f       # Size [Padding with 0s]
		#   - %+      # For: d, f       # Force sign
		#   - %*      # For: d, f, s, t # Size from varargs
		#   - %.<num> # For:    f       # Decimal places (Rounded)
		#   - %.*     # For:    f       # Decimal places from varargs (Rounded)
		# - Format arguments incompabilities:
		#   - "-" or "0" without size
		#   - "-" and "0" together
		
		# EXAMPLES:
		func.println(func.format(Simple "%%" sign!))
		func.printf(A simple text: "%s"\n, TEST - ABC)
		func.printf(A simple translation value: "%t"\n, lang.value)
		func.printf(Lang name "%15t"\, lang file version "%-15t"\n, lang.name, lang.version)
		func.printf(Numbers: %04d %04d %04d\n, 42, 43, 44)
		func.printf(Numbers: %0*d %0*d %0*d\n, 2, 42, 3, 43, 4, 44)
		func.printf(Floating point numbers: %-*.*f $\n, 10, 2, 20.2567)
		func.printf(Floating point numbers: %-+10.*f $\n, 2, 20.2367) # "+" must be behind "-"
		func.printf(Floating point numbers: %0*.2f $\n, 10, 20.2567)
		func.printf(Floating point numbers: %+010.2f $\n, 20.2367)
	}
	
	func.println()
	
	# Division by 0 in "func.div", "func.divf", and "func.divd"
	{
		# x/0: INFITIY
		# -x/0: -INFITIY
		# x/-0: -INFITIY
		# -x/-0: INFITIY
		
		func.println(func.div(2, 0))
		func.println(func.div(2, -0.))
		func.println(func.div(-2, 0))
		func.println(func.div(-2, -0.))
		
		func.println()
		
		func.println(func.divf(2, 0))
		func.println(func.divf(2, -0.))
		func.println(func.divf(-2, 0))
		func.println(func.divf(-2, -0.))
		
		func.println()
		
		func.println(func.divd(2, 0))
		func.println(func.divd(2, -0.))
		func.println(func.divd(-2, 0))
		func.println(func.divd(-2, -0.))
	}
	
	func.println()
	
	# New text functions
	{
		# func.contains(TEXT, TEXT)
		func.println(func.contains(test, t)) # 1
		func.println(func.contains(test, a)) # 0
		func.println(func.contains(test, test)) # 1
		func.println(func.contains(test, \e)) # 1
		
		func.println()
		
		# func.repeatText(INT, VARARGS)
		func.println(func.repeatText(0, test, abc)) # Empty text
		func.println(func.repeatText(1, test, abc))
		func.println(func.repeatText(2, test, abc))
		func.println(func.repeatText(3, test, abc))
		func.println(func.repeatText(4, test, abc))
		func.println(func.repeatText(0, test)) # Empty text
		func.println(func.repeatText(1, test))
		func.println(func.repeatText(2, test))
		func.println(func.repeatText(3, test))
		func.println(func.repeatText(4, test))
		
		func.println()
		
		# func.startsWith(TEXT, TEXT)
		# func.endsWith(TEXT, TEXT)
		func.println(func.startsWith(abc, a)) # 1
		func.println(func.startsWith(abc, c)) # 0
		func.println(func.startsWith(abc, ab)) # 1
		func.println(func.startsWith(abc, bc)) # 0
		func.println(func.startsWith(abc, abc)) # 1
		func.println(func.startsWith(abc, \e)) # 1
		func.println(func.endsWith(abc, a)) # 0
		func.println(func.endsWith(abc, c)) # 1
		func.println(func.endsWith(abc, ab)) # 0
		func.println(func.endsWith(abc, bc)) # 1
		func.println(func.endsWith(abc, abc)) # 1
		func.println(func.endsWith(abc, \e)) # 1
		
		func.println()
		
		# func.charsOf(VARARGS) # Returns an array with all chars of the TEXT
		func.println(func.charsOf())
		func.println(func.charsOf(42))
		func.println(func.charsOf(test))
		func.println(func.charsOf(test, abc))
		
		func.println()
		
		# func.matches(TEXT, TEXT) # RegEx matching "{{{}}}" should be used because of RegEx backlashes
		func.println(func.matches(test, test)) # 1
		func.println(func.matches(test, t.?st)) # 1
		func.println(func.matches(tst, t.?st)) # 1
		func.println(func.matches(tt, t.?st)) # 0
		func.println(func.matches(tt, t.*)) # 1
		func.println(func.matches(t, t.*)) # 1
		func.println(func.matches(tt, t.+)) # 1
		func.println(func.matches(t, t.+)) # 0
	}
	
	func.println()
	
	# New array functions
	{
		# func.arrayIndexOf(ARRAY, ANY) # Returns the first index where the data object was found or -1
		# func.arrayLastIndexOf(ARRAY, ANY) # Returns the last index where the data object was found or -1
		
		# Uses STRICT equals internally
		
		&arr = func.arrayOf(1, 2, test, func.toLong(2), abc, a, {{{a}}}, a)
		func.println(func.arrayIndexOf(&arr, a)) # 5
		func.println(func.arrayLastIndexOf(&arr, a)) # 7
		func.println(func.arrayIndexOf(&arr, {{{a}}})) # 6
		func.println(func.arrayIndexOf(&arr, 2)) # 1
		func.println(func.arrayIndexOf(&arr, func.toLong(2))) # 3
		func.println(func.arrayIndexOf(&arr, 1)) # 0
		func.println(func.arrayIndexOf(&arr, func.toLong(1))) # -1
		func.println(func.arrayIndexOf(&arr, 42)) # -1
	}
	
	func.println()
	
	# Operation functions
	{
		# func.inc(val1) # Increment
		# func.dec(val1) # Decrement
		# func.pos(val1) # Positive
		# func.inv(val1) # Negative
		# func.add(val1, val2) # Add
		# func.sub(val1, val2) # Subtract
		# func.mul(val1, val2) # Multiply
		# func.pow(val1, val2) # Power
		# func.div(val1, val2) # Division
		# func.floorDiv(val1, val2) # Floor division
		# func.mod(val1, val2) # Modulo
		# func.and(val1, val2) # Bitwise and
		# func.or(val1, val2) # Bitwise or
		# func.xor(val1, val2) # Bitwise xor
		# func.not(val1) # Bitwise not
		# func.lshift(val1, val2) # Left shift
		# func.rshift(val1, val2) # Right shift
		# func.rzshift(val1, val2) # Right zero shift
		# func.len(val1) # Length
		# func.getItem(val1, val2) # Get item (e.g. element of array, char of text)
		
		func.println(func.inc(2)) # 3
		func.println(func.inc(2.5)) # 3.5
		
		func.println()
		
		func.println(func.dec(2)) # 1
		func.println(func.dec(2.5)) # 1.5
		
		func.println()
		
		func.println(func.pos(42)) # 42
		func.println(func.pos(2.5)) # 2.5
		func.println(func.pos(0)) # 0
		func.println(func.pos(0.)) # 0.0
		
		func.println()
		
		func.println(func.inv(42)) # -42
		func.println(func.inv(2.5)) # -2.5
		func.println(func.inv(0)) # 0
		func.println(func.inv(0.)) # -0.0
		func.println(func.inv(func.arrayOf(abc, test, 42))) # [42, test, abc]
		
		func.println()
		
		func.println(func.add(42, 2)) # 44
		func.println(func.add(42.2, 2.3)) # 44.5
		func.println(func.add(42.2, .5)) # 42.7
		func.println(func.add(42, .0)) # 42.0
		func.println(func.add(test, -abc)) # test-abc
		func.println(func.add(func.arrayOf(abc, test, 42), element)) # [abc, test, 42, element]
		
		func.println()
		
		func.println(func.sub(42, 2)) # 40
		func.println(func.sub(42.2, 2.3)) # 39.9
		func.println(func.sub(42.2, .5)) # 41.7
		func.println(func.sub(42, .0)) # 42.0
		
		func.println()
		
		func.println(func.mul(42, 2)) # 48
		func.println(func.mul(42.2, 2.3)) # 97.06
		func.println(func.mul(42.2, .5)) # 21.1
		func.println(func.mul(42.2, .0)) # 0.0
		func.println(func.mul(test, 2)) # testtest
		
		func.println()
		
		func.println(func.pow(42, 2)) # 1764.0
		func.println(func.pow(42.2, 2.3)) # 5472.9134199161135
		func.println(func.pow(42.2, .5)) # 6.496152766287093
		func.println(func.pow(42.2, .0)) # 1.0
		
		func.println()
		
		func.println(func.div(4, 2)) # 2
		func.println(func.div(4, 3)) # 1.3333334
		func.println(func.div(5, 2.5)) # 2.0
		func.println(func.div(6, 2.5)) # 2.4
		
		func.println()
		
		func.println(func.floorDiv(4, 2)) # 2
		func.println(func.floorDiv(4, 3)) # 1
		func.println(func.floorDiv(5, 2.5)) # 2.0
		func.println(func.floorDiv(6, 2.5)) # 2.0
		
		func.println()
		
		func.println(func.mod(4, 2)) # 0
		func.println(func.mod(4, 3)) # 1
		func.println(func.mod(4, -2)) # 0
		func.println(func.mod(4, -3)) # 1
		func.println(func.mod(-4, 2)) # 0
		func.println(func.mod(-4, 3)) # -1
		func.println(func.mod(-4, -2)) # 0
		func.println(func.mod(-4, -3)) # -1
		
		func.println()
		
		func.println(func.and(4, 2)) # 0
		func.println(func.and(4, 3)) # 0
		func.println(func.and(5, 3)) # 1
		func.println(func.and(10, 9)) # 8
		func.println(func.and(5, -1)) # 5
		func.println(func.and(5, 0)) # 0
		func.println(func.and(func.toLong(-1), -1)) # -1
		
		func.println()
		
		func.println(func.or(4, 2)) # 6
		func.println(func.or(4, 3)) # 7
		func.println(func.or(5, 3)) # 7
		func.println(func.or(10, 9)) # 11
		func.println(func.or(5, -1)) # -1
		func.println(func.or(5, 0)) # 5
		func.println(func.or(func.toLong(-1), -1)) # -1
		
		func.println()
		
		func.println(func.xor(4, 2)) # 6
		func.println(func.xor(4, 3)) # 7
		func.println(func.xor(5, 3)) # 6
		func.println(func.xor(10, 9)) # 3
		func.println(func.xor(5, -1)) # -6
		func.println(func.xor(5, 0)) # 5
		func.println(func.xor(func.toLong(-1), -1)) # 0
		
		func.println()
		
		func.println(func.not(2)) # -3
		func.println(func.not(3)) # -4
		func.println(func.not(-1)) # 0
		func.println(func.not(0)) # -1
		
		func.println()
		
		func.println(func.lshift(4, 2)) # 16
		func.println(func.lshift(4, 3)) # 32
		func.println(func.lshift(5, -1)) # -2147483648
		func.println(func.lshift(5, 0)) # 5
		
		func.println()
		
		func.println(func.rshift(4, 2)) # 1
		func.println(func.rshift(4, 3)) # 0
		func.println(func.rshift(5, -1)) # 0
		func.println(func.rshift(5, 0)) # 5
		func.println(func.rshift(-42, 2)) # -11
		
		func.println()
		
		func.println(func.rzshift(4, 2)) # 1
		func.println(func.rzshift(4, 3)) # 0
		func.println(func.rzshift(5, -1)) # 0
		func.println(func.rzshift(5, 0)) # 5
		func.println(func.rzshift(-42, 2)) # 1073741813
		
		func.println()
		
		func.println(func.len(abctest)) # 7
		func.println(func.len(func.arrayOf(1, 42, 3, abc, test))) # 5
		
		func.println()
		
		func.println(func.getItem(abctest, 2)) # c
		func.println(func.getItem(abctest, 4)) # e
		func.println(func.getItem(func.arrayOf(1, 42, 3, abc, test), 2)) # 3
		func.println(func.getItem(func.arrayOf(1, 42, 3, abc, test), 3)) # abc
	}
}
